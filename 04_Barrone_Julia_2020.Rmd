---
title: 'Homework #4'
author: "Julia Barrone"
date: "10/5/2020"
output: html_document
---
Libraries needed 

```{r libraries}
library(dplyr)
library(lubridate)
library(tidyr)
library(tidyverse)
```


1. Write a function that takes a vector and returns one bootstrapped sample from said vector. Demonstrate that it works.
```{r 1}

vec <- c(2,4,6,8,9,0,5,3,2)#defining my vector 

bootstrap_vector <- function(vec){#creating a new function of vec 
  one_bootstrap <- sample(vec,#taking one bootstrap of a sample of vec that is the size of the length of vec which is 9. Yes to replacement
        size = length(vec),
        replace = TRUE)

  return(one_bootstrap)#telling the function to return a bootstrap 
  
}

bootstrap_vector(c(2,4,6,8,9,0,5,3,2)) #testing my function to see if it returns a bootstrap sample of that vector 


```

2. Write a function that given a vector of values a request for some number of bootstraps (let’s call the parameter R), and a sample statistic function (e.g., mean, IQR, etc.) returns R number of values of that statistic. Have it default to R = 1000 and the function is mean. Show this works for 10 bootstrapped replicate draws of a mean from some vector. Do the values look reasonable? Compare to the actual mean of the vector (make sure you are using the function(s) you wrote in #1)
```{r 2}
library(dplyr)

function_bootstrap_mean <- function(vec, R = 1000){#creating a new function of vec called function_bootstrap_mean. Telling it to replicate 10 times 
  boot_mean <- replicate(R,#naming the bootstrapped means boot_mean. Already defined replicate above to 10
                       sample(vec, #sample the vector I created 
                              size = length(vec), #defining the size as the length of my vector 
                              replace = TRUE) %>% mean) #yes to replacement and asking the function to return the mean 
  return(boot_mean)#telling the function to return a bootstrap of the mean 
  
}

function_bootstrap_mean(c(2,4,6,8,9,0,5,3,2), R=10) #showing that it works to return 10 bootstrapped replicate draws from my vector from #1


mean(vec)#The actual mean of the vector is 4.3333

#The values in my bootstapped replicate draws of the mean for my vector ranged from 3.3333 all the way up to 6. There were 4 values that were close to the actual mean of 4.3333. Overall, I think the values were reasonable. 
```

3. Write a function that, given a vector of values a request for some number of bootstraps, and a sample statistic function, returns the original value of the statistic as applied to the vector, the mean of the statistic generated by the bootstrapped reps, the upper and lower 95% CI of the bootstrapped statistic (e.g., the 0.025 and 0.975 quantile), and the bias (i.e., the original value of the statistic - the mean of the bootstrapped statistic).(make sure you are using the function(s) you wrote in #1)
```{r 3}

vec <- c(2,4,6,8,9,0,5,3,2)

new_function <- function(vec, R=1000){#creating a new function of my vec called new_function
  
  vec_mean <- mean(vec) #getting the mean of my vec and labeling
  bootstrap_mean <- function_bootstrap_mean(vec) #using the bootstrap function from #2, I applied it to my vec to get my bootstrapped replicates 
  lower_ci <- quantile(bootstrap_mean, probs = 0.025) #asking for the lower quantile
  upper_ci <- quantile(bootstrap_mean, probs = 0.975) #asking for the upper quantile 
  bias <- mean(vec) - mean(bootstrap_mean) #finding the bias
 
 return_vector <- c(vec_mean, mean(bootstrap_mean), upper_ci, lower_ci, bias) #summarizing from above and asking for these values in my return vector 
 
  return(return_vector) #return
}

test <- new_function(vec, R=10)#testing the function to see if I get the right output 

test #This function returns the original mean, the bootstrapped mean, the upper and lower CIs along with the bias. 



```

4. FiveThirtyEight keeps a great archive of poll data at https://projects.fivethirtyeight.com/polls/. The presidential general election polling data is freely available at https://projects.fivethirtyeight.com/polls-page/president_polls.csv with question, poll id, and cycle defining a unique poll.

4a. Download and look at the data. Is it long or wide?
```{r 4a}

#The data is long because each question_id has multiple rows of data

```

4b. Get just the polling data for this last week (from 9/29 to today). Filter on start_date. Also filter down to just Biden and Trump (see candidate_name or answer). Extra credit for using {lubridate} for this, but you can just do a messy %in% string match.
```{r 4b}

polling_data <-read.csv("president_polls.csv")#loading the excel file of polling data to R 

filter_polling <- polling_data %>% #creating a new dataset that is filtered with date ranges and candidate_name 
    filter(start_date >= as.Date("2020-09-29")) %>% #filtering the start date to greater than or equal to 2020-009-29 
  filter(candidate_name == "Joseph R. Biden Jr." | candidate_name == "Donald Trump") %>%#filtering the candidate_name to include only Biden and Trump 
  filter(na.rm = TRUE) #removing NAs


filter_polling

  
```


4c. OK, this is your sample. What’s the bootstrapped average percentage for each candidate for nationwide polls (state == "")? Note, this answer will not match 538 given their weighting by poll trustworthiness.
```{r 4c}

boot_poll <- filter_polling %>% 
  group_by(answer) %>%#grouping by the candidate name, Biden or Trump
  filter(state == "") %>% #filtering by empty cells of space to get the national polls 
  summarize(sample(filter_polling$pct,#summarizing the data of the pct column to get the avg bootstrapped percentage for each candidate
                                        size = filter_polling$pct,#setting size to the pct column
                                        replace = TRUE) %>% mean)#asking for the average

boot_poll #testing to see if it works  

#Biden	45.30392		
#Trump	45.71961	
```

4d. What is the average difference between the two candidates by state and national polls? Note, you’ll need to make this a wide data frame to answer! And, well, try the pivot without this advice first, but then….
make a unique ID by pasting together the question_id, poll_id, and state. Then select the ID, state, answer, and pct. Also filter out NA diffs
```{r 4d}


new_data <- filter_polling %>%
 mutate(ID = paste(question_id, poll_id, state, sep = "_")) %>%
  select("ID", "state", "answer", "pct")#making a new dataframe by adding an ID column containing question_id, poll_id and state all separated with a _ , Then, I want to select my new ID column, the state, answer and pct columns to be in my new dataframe. 


poll_wide <- new_data %>% 
  pivot_wider(names_from = answer,
              values_from = pct) %>% #making my new dataframe into a wide data frame making my new columns labeled from the answer column taking values from pct. 
  na.omit() %>% #asking to omit NAs 
  group_by(state) %>% #grouping by state to show the differences in national and state 
  mutate(candidate_mean_diffBT = mean(Biden - Trump), #column of Biden- Trump mean difference 
         candidate_mean_diffTB = mean(Trump - Biden)) %>% #column of Trump-Biden mean difference 
  ungroup() #ungrouping 

poll_wide

#The national polling mean difference was 7.576471 and the state polling mean difference varied by state. 
```



5. replicate() has been our friend, but we’ve always had to be a little hacky with it. We’ve either had to fold in means, or use tricksy functions like colMeans and the like.
BUT - what’s interesting about replicate() is that, if you ask it to turn back raw draws from a random number generator - or anything with more than one value - it gives you a matrix or array.


5a. So, I want you to, using the mean and SD of Biden’s national polling average (you’ll need to calculate it!) from above, simulate 1000 draws from that population with a sample size of 50. What are the dimensions of the object. What are in the rows and columns?
```{r 5a}

Biden_poll <- filter_polling %>% 
  filter(answer == "Biden") %>%
  filter(state == "")#filtering out a new data frame that contains just Biden's info for national polls.
  
New_Biden_poll <- Biden_poll %>%#using my new df of ony Biden's national polls
  mutate(Mean = mean(Biden_poll$pct),#finding the mean of Biden's national polling avg
        SD = sd(Biden_poll$pct)) #finding the mean of Biden's national polling

#mean is  48.46316
# sd is 2.824341

samp <- rnorm(50, mean = New_Biden_poll$Mean, sd = New_Biden_poll$SD)
#setting my sample to size 50, and defining my mean and sd of my sample. 

simulation <- replicate(1000, #1000 draws
                      sample(samp, 
                             size = length(samp),# setting the sample and size to my already defined sample 
                             replace = TRUE))#yes to replacement 

View(simulation)
# The dimensions of my object are 50 x 1000. The rows represent each sample(50) and the columns lists each draw of the mean (1000 columns)
```

5b. Yuck. Can you turn this into something usable? Say, first make it a tibble or data frame, and then pivot it to long, such that you end up with a column that has an identifier for sim and a column with a single value from that sim? (Oh, and for all columns, cols = everything())
```{r 5b}

cleaner_sim <- data.frame(simulation) #turning my simulation data into a usable data frame 

cleaner_sim_long <- cleaner_sim %>% #pivoting the data frame to long to create 2 columns, one labeling and the other with a single value from the simulation 
  pivot_longer(names_to = "sim",
               values_to = "pct",
               cols = everything())

cleaner_sim_long #checking to see if it pivoted to long correctly. One column labels each sim and the other column contains each sim polling mean for Biden


```

5c. For each sim, what’s the bootsrapped mean and CI? Plot it! And tell us how often it’s greater than the initial mean. E.C. for the plot showing the stats in order from low to high.
```{r 5c}

library(ggplot2)#load ggplot 

plot_sim <- cleaner_sim_long %>% #creating a df that will contain new columns 
  group_by(sim) %>% #grouping by the simulations
  summarize("Mean" = mean(pct), #summarizing to have a mean of the pct column, lower quantile, and upper quantile column of each simulation 
  "Lower_CI" = quantile(pct, probs = 0.025), #asking for the lower quantile
  "Upper_CI" = quantile(pct, probs = 0.975))#asking for the upper quantile 



ggplot(data = plot_sim, mapping = aes(x = sim, y = Mean, ymin=Lower_CI, ymax=Upper_CI)) +
  geom_pointrange() +
  geom_hline(yintercept = 48.46316, color = "white", linetype = "dotted") #using ggplot to plot simulations on the y axis and mean on the x axis. Using geom_pointrange and setting ymin to the lower quantile and ymax to the upper quantile.  Plotting a line to show the actual mean of the percents just for clarification


#initial mean = 48.46316

length(plot_sim$Mean > 48.46316) #getting the number of bootstrapped means that are above the initial mean. It appears there are 1000 bootstrapped means above the inital 
  
```

5d. So…. what is that plot showing? What are the concepts involved?
```{r 5d}

#I used a geom_pointrange plot to display the bootstrapped means and the upper and lower CIs. geom_pointrange has the ability to plot point ranges and show the upper and lower CIs when defined. Thus, it was a convenient plot to display all the bootstrapped means in an visually appealing way. It just shows the breadth of all the bootstraps. Most of the bootstrapped means are close to the actual mean but you can see at the top of the graph, some higher bootstapped means. The actual mean is defined by the white dotted line. Although it is hard to see on the plot because there are so many points, the geom_point range is like a boxplot in that each point displays the mean and lines displaying the confidence intervals. 
  
```

My github homework link is here: https://github.com/Jbarrone95/Biol-607-Homework- 